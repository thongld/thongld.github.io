891
00:38:59,240 --> 00:39:00,350
NghiaNguyen 6-6-2016 Thao reviewed
Không.

892
00:39:00,350 --> 00:39:01,770
-1 nhỏ hơn.

893
00:39:01,770 --> 00:39:03,870
Con số thứ 2 là 41.

894
00:39:03,870 --> 00:39:06,120
41 có nhỏ hơn -1 không ?

895
00:39:06,120 --> 00:39:07,870
Không.

896
00:39:07,870 --> 00:39:08,910
Con số tiếp theo là 12.

897
00:39:08,910 --> 00:39:10,686
Nó có nhỏ hơn -1 không?

898
00:39:10,686 --> 00:39:11,660
Không.

899
00:39:11,660 --> 00:39:14,130
-1 nhỏ hơn 12.

900
00:39:14,130 --> 00:39:15,000
3?

901
00:39:15,000 --> 00:39:17,450
Không nhỏ hơn.

902
00:39:17,450 --> 00:39:19,024
74?

903
00:39:19,024 --> 00:39:20,850
Không.

904
00:39:20,850 --> 00:39:22,360
15?

905
00:39:22,360 --> 00:39:24,510
Vẫn không nhỏ hơn.

906
00:39:24,510 --> 00:39:27,670
Hoàn tất rồi.
Số nhỏ nhất ta thấy

907
00:39:27,670 --> 00:39:33,540
trong đây là -1 ?

908
00:39:33,540 --> 00:39:35,710
Nhưng -1 không nằm trong list.

909
00:39:35,710 --> 00:39:37,876
Vậy đây là 1 chương trình lỗi.

910
00:39:37,876 --> 00:39:41,860

911
00:39:41,860 --> 00:39:44,860
Ta hãy tìm xem chương trình có gì sai.

912
00:39:44,860 --> 00:39:48,240
Ta đã cố gắng hết sức để sửa nó.

913
00:39:48,240 --> 00:39:50,190
Ta đã đổi
tên biến từ largest sang smallest,

914
00:39:50,190 --> 00:39:52,056
tốt quá.

915
00:39:52,056 --> 00:39:53,930
Nhưng chỉ làm cho chương trình dễ đọc hơn chứ

916
00:39:53,930 --> 00:39:54,930
chưa thay đổi được gì mấy.

917
00:39:54,930 --> 00:39:56,490
Và ta đã sửa thành dấu nhỏ hơn.

918
00:39:56,490 --> 00:39:58,530
Bây giờ chương trình bắt đầu.

919
00:39:58,530 --> 00:40:01,770
Nếu 3 nhỏ hơn -1 thì 
tất nhiên smallest_so_far

920
00:40:01,770 --> 00:40:03,525
là -1.

921
00:40:03,525 --> 00:40:05,520
Cái này không bao giờ chạy.

922
00:40:05,520 --> 00:40:06,500
Không bao giờ chạy.

923
00:40:06,500 --> 00:40:10,610
Khi in ra màn hình,
smallest_so_far vẫn là -1.

924
00:40:10,610 --> 00:40:16,340
Ôi, cái này phải là -1 mới đúng.

925
00:40:16,340 --> 00:40:18,450
Xin lỗi, tôi quên sửa.

926
00:40:18,450 --> 00:40:20,670
Bây giờ tôi sẽ phù phép sửa nó.

927
00:40:20,670 --> 00:40:23,620

928
00:40:23,620 --> 00:40:27,320
Ta hãy nhìn xem lỗi ở đâu nhé.

929
00:40:27,320 --> 00:40:28,510
Chúng ta có đoạn code này.

930
00:40:28,510 --> 00:40:29,843
Smallest_so_far là -1.

931
00:40:29,843 --> 00:40:31,740
Ta đã sửa dấu này thành nhỏ hơn

932
00:40:31,740 --> 00:40:34,090
để tìm các số nhỏ hơn

933
00:40:34,090 --> 00:40:36,050
thay vì các số lớn.

934
00:40:36,050 --> 00:40:40,890
Nhưng lần đầu tiên chạy,
smallest_so_far vẫn là -1

935
00:40:40,890 --> 00:40:42,990
và the_num là 3.

936
00:40:42,990 --> 00:40:47,140
3 không nhỏ hơn -1,
chúng ta bỏ qua.

937
00:40:47,140 --> 00:40:50,470
Và dòng đầu tiên 
in ra màn hình là -1   3.

938
00:40:50,470 --> 00:40:53,380
Ta nhận ra ngay là chương trình sẽ

939
00:40:53,380 --> 00:40:54,610
cứ chạy thế này thôi.

940
00:40:54,610 --> 00:40:57,720
Smallest_so_far vẫn là -1 cho dù bên này

941
00:40:57,720 --> 00:40:59,570
là giá trị gì đi nữa.

942
00:40:59,570 --> 00:41:02,240
Sau đó, tới
đoạn cuối cùng,

943
00:41:02,240 --> 00:41:05,876
ta kết thúc với 
đáp án là -1.

944
00:41:05,876 --> 00:41:07,138
Không ổn tí nào.

945
00:41:07,138 --> 00:41:09,890

946
00:41:09,890 --> 00:41:17,140
Vậy câu hỏi ở đây là chúng ta nên
gán giá trị gì vào chỗ này?

947
00:41:17,140 --> 00:41:19,694
-1 chỉ dùng được trong
bài toán tìm số lớn nhất

948
00:41:19,694 --> 00:41:21,610
bởi khi đó ta làm việc 
với các số dương.

949
00:41:21,610 --> 00:41:22,984
Vì vậy bắt đầu
với largest_so_far bằng -1 

950
00:41:22,984 --> 00:41:25,655
là hợp lý, miễn là các số

951
00:41:25,655 --> 00:41:27,030
cần xét đều dương.

952
00:41:27,030 --> 00:41:29,700

953
00:41:29,700 --> 00:41:32,946
Vậy ở đây nên chọn số nào?

954
00:41:32,946 --> 00:41:34,070
Các bạn thử nghĩ xem.

955
00:41:34,070 --> 00:41:35,610
Tạm dừng nếu
cần thêm thời gian.

956
00:41:35,610 --> 00:41:37,510
Để tôi xóa cái này.

957
00:41:37,510 --> 00:41:40,570
Tôi sẽ nói cho thật rõ nhé.

958
00:41:40,570 --> 00:41:42,430
Chỗ này nên đặt con số nào?

959
00:41:42,430 --> 00:41:46,530

960
00:41:46,530 --> 00:41:49,300
1 triệu được không?

961
00:41:49,300 --> 00:41:52,910

962
00:41:52,910 --> 00:41:55,450
Cũng có thể đấy.

963
00:41:55,450 --> 00:41:56,820
1 triệu có thể được.

964
00:41:56,820 --> 00:42:05,890
Nhưng nếu các số này đều lớn hơn 1 triệu thì sao?

965
00:42:05,890 --> 00:42:07,110
Thế lại không được.

966
00:42:07,110 --> 00:42:10,430
Vậy vấn đề là không có giá trị nào thật phù hợp cả,

967
00:42:10,430 --> 00:42:13,270
trừ khi bạn làm sao cho được dương vô cùng vào đây.

968
00:42:13,270 --> 00:42:15,950

969
00:42:15,950 --> 00:42:18,340
Cho nó thành dương vô cùng.

970
00:42:18,340 --> 00:42:22,050
Nhưng trong Python có một thủ thuật rất hay

971
00:42:22,050 --> 00:42:24,050
để giải quyết vấn đề này.

972
00:42:24,050 --> 00:42:26,640
Nó là 1 cách mà ta tự biểu thị mình.

973
00:42:26,640 --> 00:42:29,570
Và đó là, ta sẽ dùng
1 giá trị đặc biệt.

974
00:42:29,570 --> 00:42:31,530
Không phải -1, 
không phải dạng số.

975
00:42:31,530 --> 00:42:35,890
Và giá trị đặc biệt mà 
chúng ta sẽ dùng là None.

976
00:42:35,890 --> 00:42:37,550
Nó là 1 kiểu khác.

977
00:42:37,550 --> 00:42:41,139
Nó không phải số, mà tự nó là một kiểu riêng.

978
00:42:41,139 --> 00:42:43,680
Vậy ta sẽ gán giá trị smallest (nhỏ nhất) là None.

979
00:42:43,680 --> 00:42:48,220
Có thể hiểu như ta đang nói rằng

980
00:42:48,220 --> 00:42:50,010
đến giờ ta vẫn chưa thấy gì cả.

981
00:42:50,010 --> 00:42:52,950
Giá trị nhỏ nhất mà 
ta có tới giờ là None.

982
00:42:52,950 --> 00:42:55,140
Chúng ta chưa thấy cái gì cả.

983
00:42:55,140 --> 00:42:57,856
Bây giờ ta phải thay đổi
câu if trong vòng lặp này,

984
00:42:57,856 --> 00:43:00,410
đổi đoạn code thông minh ở giữa này.

985
00:43:00,410 --> 00:43:04,450
Đầu tiên ta nói if smallest is None, 
"is" là 1 toán tử.

986
00:43:04,450 --> 00:43:06,300
Một phần của ngôn ngữ Python.

987
00:43:06,300 --> 00:43:10,200
If smallest is None, 
tức nếu if đúng là None,

988
00:43:10,200 --> 00:43:12,477
thì smallest mà ta 
có hiện tại sẽ là value.

989
00:43:12,477 --> 00:43:14,310
Cái này chỉ chạy một lần đầu

990
00:43:14,310 --> 00:43:17,320

991
00:43:17,320 --> 00:43:18,987
vì smallest bắt đầu bằng None.

992
00:43:18,987 --> 00:43:21,070
Và ngay khi chúng ta gán 
giá trị value cho smallest,

993
00:43:21,070 --> 00:43:22,528
thì smallest sẽ trở thành con số đó.

994
00:43:22,528 --> 00:43:24,010
Vậy nó sẽ bằng 9.

995
00:43:24,010 --> 00:43:27,110
Trong tích tắc, ta có smallest là 9.

996
00:43:27,110 --> 00:43:30,740
Ta in ra màn hình
smallest là 9

997
00:43:30,740 --> 00:43:33,010
sau khi đã gặp số 9.

998
00:43:33,010 --> 00:43:37,050
Tiếp theo ta quay lại từ đầu
và kiểm tra smallest có phải None không?

999
00:43:37,050 --> 00:43:41,320
Câu trả lời là không, vì 
bây giờ smallest là 9.

1000
00:43:41,320 --> 00:43:43,200
Rồi dòng elif này sẽ hỏi,

1001
00:43:43,200 --> 00:43:46,090
value ta đang xét tức 41

1002
00:43:46,090 --> 00:43:47,680
có nhỏ hơn smallest không?

1003
00:43:47,680 --> 00:43:50,410
Không.

1004
00:43:50,410 --> 00:43:52,530
9 nhỏ hơn 41.

1005
00:43:52,530 --> 00:43:57,170
Có thể hiểu rằng, sau lần 
thực thi đầu tiên của câu lệnh này

1006
00:43:57,170 --> 00:43:59,890
đoạn này sẽ luôn là 
false, đúng không?

1007
00:43:59,890 --> 00:44:01,860
Bởi vì smallest không còn là None nữa.

1008
00:44:01,860 --> 00:44:04,820
Vậy đoạn này sẽ là cơ chế hoạt động chính.

1009
00:44:04,820 --> 00:44:06,240
Sau đó nó sẽ hoạt động được.

1010
00:44:06,240 --> 00:44:10,930
Smallest sẽ là 9, giá trị 
nhỏ nhất hiện tại là 9, 

1011
00:44:10,930 --> 00:44:12,860
nhưng rồi ta sẽ thấy 3.

1012
00:44:12,860 --> 00:44:16,890
Và 3 nhỏ hơn 9, 
nên ta gán 3

1013
00:44:16,890 --> 00:44:18,680
vào biến smallest.

1014
00:44:18,680 --> 00:44:20,260
Ta có kết quả thế này.

1015
00:44:20,260 --> 00:44:23,824
Vòng lặp chạy tiếp vài lần nữa, 
khi xong việc, ta có

1016
00:44:23,824 --> 00:44:25,510
đáp án 3.

1017
00:44:25,510 --> 00:44:29,280
Vậy, thủ thuật ở đây là,
ta đưa vào giá trị None

1018
00:44:29,280 --> 00:44:31,180
và thêm 1 đoạn code if

1019
00:44:31,180 --> 00:44:34,342
để kiểm tra xem ta
có thấy con số nào chưa?

1020
00:44:34,342 --> 00:44:36,050
Bạn có thể hình dung cái này là để khởi động

1021
00:44:36,050 --> 00:44:38,585
cho bước lặp đầu tiên.

1022
00:44:38,585 --> 00:44:41,320

1023
00:44:41,320 --> 00:44:43,486
Đoạn code đặc biệt này
sẽ được chạy ở

1024
00:44:43,486 --> 00:44:45,360
mỗi vòng lặp, nhưng sau bước lặp đầu tiên

1025
00:44:45,360 --> 00:44:48,260
nó sẽ không bao giờ true nữa.

1026
00:44:48,260 --> 00:44:49,410
Vậy đó là một thủ thuật.

1027
00:44:49,410 --> 00:44:52,260

1028
00:44:52,260 --> 00:44:54,030
Đây là toán tử is not.

1029
00:44:54,030 --> 00:44:56,490
Tôi thấy nó rất hay.

1030
00:44:56,490 --> 00:44:59,975
Đừng lạm dụng nó nhé.

1031
00:44:59,975 --> 00:45:04,030
Ý nghĩa thực sự của nó là

1032
00:45:04,030 --> 00:45:07,570
giống hệt nhau về kiểu dữ liệu và giá trị.

1033
00:45:07,570 --> 00:45:10,510
Có hai toán tử "is" và "is not".

1034
00:45:10,510 --> 00:45:15,530
Nhưng các bạn đừng viết kiểu
nếu i bằng -- ối.

1035
00:45:15,530 --> 00:45:18,340

1036
00:45:18,340 --> 00:45:20,090
Muốn cố tình viết sai tí cũng không xong.

1037
00:45:20,090 --> 00:45:25,050
Đừng viết kiểu if i is 4.

1038
00:45:25,050 --> 00:45:25,740
Không được nhé.

1039
00:45:25,740 --> 00:45:27,740
Đừng viết i is 4.

1040
00:45:27,740 --> 00:45:30,490

1041
00:45:30,490 --> 00:45:32,260
Nó có thể vẫn đúng trong một số trường hợp.

1042
00:45:32,260 --> 00:45:34,510
Tốt nhất là chỉ dùng nó trong các trường hợp

1043
00:45:34,510 --> 00:45:36,760
cần kiểm tra các giá trị đặc biệt

1044
00:45:36,760 --> 00:45:39,035
như None và False.

1045
00:45:39,035 --> 00:45:41,590

1046
00:45:41,590 --> 00:45:44,970
Vấn đề là nếu ta 
dùng phép so sánh == ở đây.

1047
00:45:44,970 --> 00:45:49,090
nó sẽ chuyển đổi 
các giá trị và có thể

1048
00:45:49,090 --> 00:45:51,010
cho bạn một kết quả sai.

1049
00:45:51,010 --> 00:45:56,180
Vậy "is" là phép so sánh mạnh 
hơn so sánh bằng ==.

1050
00:45:56,180 --> 00:46:00,470
So sánh bằng == là có cùng giá trị số,

1051
00:46:00,470 --> 00:46:02,680
còn is nghĩa là cùng là một thứ.

1052
00:46:02,680 --> 00:46:04,740
Nhưng đừng lạm dụng "is".

1053
00:46:04,740 --> 00:46:07,590
Thường thì 95% là dùng "=="

1054
00:46:07,590 --> 00:46:10,220
is chỉ dùng khi
bạn kiểm tra xem nó

1055
00:46:10,220 --> 00:46:13,880
có phải là hằng số 
đặc biệt như True, False không.

1056
00:46:13,880 --> 00:46:16,570
OK?

1057
00:46:16,570 --> 00:46:18,616
Vậy ta đã học xong vòng lặp.

1058
00:46:18,616 --> 00:46:20,865
Các vòng lặp sẽ còn phức tạp hơn

1059
00:46:20,865 --> 00:46:22,780
và ta sẽ có thêm
nhiều cái hay để làm.

1060
00:46:22,780 --> 00:46:25,860
Hiện tại ta đã học về 
vòng lặp vô hạn,

1061
00:46:25,860 --> 00:46:28,300
vòng lặp hữu hạn, biến vòng lặp.

1062
00:46:28,300 --> 00:46:32,910
Một số cấu trúc tìm giá trị lớn nhất,
nhỏ nhất, tính tổng, tính trung bình cộng.

1063
00:46:32,910 --> 00:46:35,640
Ta cũng đã học
khái niệm None.

1064
00:46:35,640 --> 00:46:38,349
Vậy ta đã học được khá nhiều thứ.

1065
00:46:38,349 --> 00:46:40,640
Còn vài chương nữa 
là ta bắt đầu

1066
00:46:40,640 --> 00:46:41,930
đụng đến phân tích dữ liệu rồi.

1067
00:46:41,930 --> 00:46:44,680
Hẹn gặp lại các bạn ở bài tiếp theo.

